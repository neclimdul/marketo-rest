<?php

/**
 * ThankYouPageRequest
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 *
 * @category Class
 * @package  NecLimDul\MarketoRest\Asset
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Marketo Rest API
 *
 * Marketo Rest API
 *
 * OpenAPI spec version: 1.0
 * Contact: developerfeedback@marketo.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.26
 */

namespace NecLimDul\MarketoRest\Asset\Model;

use ArrayAccess;
use NecLimDul\MarketoRest\Asset\ObjectSerializer;

/**
 * ThankYouPageRequest Class Doc Comment
 *
 * @category Class
 * @package  NecLimDul\MarketoRest\Asset
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null
 */
class ThankYouPageRequest implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'ThankYouPageRequest';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var array
      * @phpstan-var array<string, string|class-string>
      * @psalm-var array<string, string|class-string>
      */
    protected static $swaggerTypes = [
        'default' => 'bool',
        'followup_type' => 'string',
        'followup_value' => 'string',
        'operator' => 'string',
        'subject_field' => 'string',
        'values' => 'string[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var array
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $swaggerFormats = [
        'default' => null,
        'followup_type' => null,
        'followup_value' => null,
        'operator' => null,
        'subject_field' => null,
        'values' => null
    ];

    /**
      * Array of additional properties.
      *
      * @var mixed[]
      */
    protected $additionalProperties = [];

    /**
     * {@inheritDoc}
     */
    public static function swaggerTypes(): array
    {
        return self::$swaggerTypes;
    }

    /**
     * {@inheritDoc}
     */
    public static function swaggerFormats(): array
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'default' => 'default',
        'followup_type' => 'followupType',
        'followup_value' => 'followupValue',
        'operator' => 'operator',
        'subject_field' => 'subjectField',
        'values' => 'values'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'default' => 'setDefault',
        'followup_type' => 'setFollowupType',
        'followup_value' => 'setFollowupValue',
        'operator' => 'setOperator',
        'subject_field' => 'setSubjectField',
        'values' => 'setValues'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'default' => 'getDefault',
        'followup_type' => 'getFollowupType',
        'followup_value' => 'getFollowupValue',
        'operator' => 'getOperator',
        'subject_field' => 'getSubjectField',
        'values' => 'getValues'
    ];

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['default'] = $data['default'] ?? null;
        $this->container['followup_type'] = $data['followup_type'] ?? null;
        $this->container['followup_value'] = $data['followup_value'] ?? null;
        $this->container['operator'] = $data['operator'] ?? null;
        $this->container['subject_field'] = $data['subject_field'] ?? null;
        $this->container['values'] = $data['values'] ?? null;
    }

    /**
     * {@inheritdoc}
     */
    public static function attributeMap(): array
    {
        return self::$attributeMap;
    }

    /**
     * {@inheritdoc}
     */
    public static function setters(): array
    {
        return self::$setters;
    }

    /**
     * {@inheritdoc}
     */
    public static function getters(): array
    {
        return self::$getters;
    }

    /**
     * {@inheritdoc}
     */
    public function getModelName(): string
    {
        return self::$swaggerModelName;
    }

    /**
     * {@inheritdoc}
     */
    public function listInvalidProperties(): array
    {
        $invalidProperties = [];

        if ($this->container['followup_type'] === null) {
            $invalidProperties[] = "'followup_type' can't be null";
        }
        if ($this->container['followup_value'] === null) {
            $invalidProperties[] = "'followup_value' can't be null";
        }
        if ($this->container['operator'] === null) {
            $invalidProperties[] = "'operator' can't be null";
        }
        if ($this->container['subject_field'] === null) {
            $invalidProperties[] = "'subject_field' can't be null";
        }
        if ($this->container['values'] === null) {
            $invalidProperties[] = "'values' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * {@inheritdoc}
     */
    public function valid(): bool
    {
        return count($this->listInvalidProperties()) === 0;
    }

    /**
     * Gets default
     *
     * @return bool
     */
    public function getDefault(): bool
    {
        return $this->container['default'];
    }

    /**
     * Sets default
     *
     * @param bool|null $default When true, this is the default rule, and will be applied when a user does not qualify for any of the other rules
     *
     * @return self<TKey, TValue>
     */
    public function setDefault(?bool $default): ThankYouPageRequest
    {
        $this->container['default'] = $default;

        return $this;
    }

    /**
     * Gets followup_type
     *
     * @return string
     */
    public function getFollowupType(): string
    {
        return $this->container['followup_type'];
    }

    /**
     * Sets followup_type
     *
     * @param string $followup_type Type of followup.  When set to url, will follow to the url set in followupValue.  When set to lp, will follow to the Landing page with the id given in followupValue
     *
     * @return self<TKey, TValue>
     */
    public function setFollowupType(string $followup_type): ThankYouPageRequest
    {
        $this->container['followup_type'] = $followup_type;

        return $this;
    }

    /**
     * Gets followup_value
     *
     * @return string
     */
    public function getFollowupValue(): string
    {
        return $this->container['followup_value'];
    }

    /**
     * Sets followup_value
     *
     * @param string $followup_value Where to follow to on submission.  Given as a URL or and Integer depending on followupType
     *
     * @return self<TKey, TValue>
     */
    public function setFollowupValue(string $followup_value): ThankYouPageRequest
    {
        $this->container['followup_value'] = $followup_value;

        return $this;
    }

    /**
     * Gets operator
     *
     * @return string
     */
    public function getOperator(): string
    {
        return $this->container['operator'];
    }

    /**
     * Sets operator
     *
     * @param string $operator Operator to evaluate aginst the subject field
     *
     * @return self<TKey, TValue>
     */
    public function setOperator(string $operator): ThankYouPageRequest
    {
        $this->container['operator'] = $operator;

        return $this;
    }

    /**
     * Gets subject_field
     *
     * @return string
     */
    public function getSubjectField(): string
    {
        return $this->container['subject_field'];
    }

    /**
     * Sets subject_field
     *
     * @param string $subject_field Field to apply to operator to
     *
     * @return self<TKey, TValue>
     */
    public function setSubjectField(string $subject_field): ThankYouPageRequest
    {
        $this->container['subject_field'] = $subject_field;

        return $this;
    }

    /**
     * Gets values
     *
     * @return string[]
     */
    public function getValues(): array
    {
        return $this->container['values'];
    }

    /**
     * Sets values
     *
     * @param string[] $values Comma-separated list of values to compare to with the operator
     *
     * @return self<TKey, TValue>
     */
    public function setValues(array $values): ThankYouPageRequest
    {
        $this->container['values'] = $values;

        return $this;
    }

    /**
     * {@inheritdoc}
     */
    public function setAdditionalProperties(array $fields): void
    {
        $fields = array_diff_key($fields, static::$attributeMap);
        foreach ($this->additionalProperties as $additional_properties) {
            unset($this->container[$additional_properties]);
        }
        $this->container += $fields;
        $keys = array_keys($fields);
        $this->additionalProperties = array_combine($keys, $keys);
    }

    /**
     * {@inheritdoc}
     */
    public function setAdditionalProperty($property, $value): void
    {
        if (isset(static::$attributeMap[$property])) {
            throw new \InvalidArgumentException();
        }
        $this->additionalProperties[$property] = $property;
        $this->container[$property] = $value;
    }

    /**
     * {@inheritdoc}
     */
    public function getAdditionalProperties()
    {
        $container = $this->container;
        $map =
            /**
             * @param array-key $key
             * @return mixed
             */
            function ($key) use ($container) {
                return $container[$key];
            };
        return array_map($map, $this->additionalProperties);
    }

    /**
     * {@inheritdoc}
     */
    #[\ReturnTypeWillChange]
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * {@inheritdoc}
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * {@inheritdoc}
     */
    #[\ReturnTypeWillChange]
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * {@inheritdoc}
     */
    #[\ReturnTypeWillChange]
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
        return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     * @throws \JsonException
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT | JSON_THROW_ON_ERROR
        );
    }
}
