<?php
/**
 * EmailsApi
 * PHP version 5
 *
 * @category Class
 * @package  NecLimDul\MarketoRest\Asset
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Marketo Rest API
 *
 * Marketo Rest API
 *
 * OpenAPI spec version: 1.0
 * Contact: developerfeedback@marketo.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.3.4
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace NecLimDul\MarketoRest\Asset\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use NecLimDul\MarketoRest\Asset\ApiException;
use NecLimDul\MarketoRest\Asset\Configuration;
use NecLimDul\MarketoRest\Asset\HeaderSelector;
use NecLimDul\MarketoRest\Asset\ObjectSerializer;

/**
 * EmailsApi Class Doc Comment
 *
 * @category Class
 * @package  NecLimDul\MarketoRest\Asset
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class EmailsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addModuleUsingPOST
     *
     * Add Email Module
     *
     * @param  int $id id (required)
     * @param  string $module_id moduleId (required)
     * @param  string $name Name of the module (required)
     * @param  int $index Index of the module.  Determines the order of the module in the email. (required)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ModelResponse
     */
    public function addModuleUsingPOST($id, $module_id, $name, $index)
    {
        list($response) = $this->addModuleUsingPOSTWithHttpInfo($id, $module_id, $name, $index);
        return $response;
    }

    /**
     * Operation addModuleUsingPOSTWithHttpInfo
     *
     * Add Email Module
     *
     * @param  int $id id (required)
     * @param  string $module_id moduleId (required)
     * @param  string $name Name of the module (required)
     * @param  int $index Index of the module.  Determines the order of the module in the email. (required)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ModelResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function addModuleUsingPOSTWithHttpInfo($id, $module_id, $name, $index)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ModelResponse';
        $request = $this->addModuleUsingPOSTRequest($id, $module_id, $name, $index);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ModelResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addModuleUsingPOSTAsync
     *
     * Add Email Module
     *
     * @param  int $id id (required)
     * @param  string $module_id moduleId (required)
     * @param  string $name Name of the module (required)
     * @param  int $index Index of the module.  Determines the order of the module in the email. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addModuleUsingPOSTAsync($id, $module_id, $name, $index)
    {
        return $this->addModuleUsingPOSTAsyncWithHttpInfo($id, $module_id, $name, $index)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addModuleUsingPOSTAsyncWithHttpInfo
     *
     * Add Email Module
     *
     * @param  int $id id (required)
     * @param  string $module_id moduleId (required)
     * @param  string $name Name of the module (required)
     * @param  int $index Index of the module.  Determines the order of the module in the email. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addModuleUsingPOSTAsyncWithHttpInfo($id, $module_id, $name, $index)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ModelResponse';
        $request = $this->addModuleUsingPOSTRequest($id, $module_id, $name, $index);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addModuleUsingPOST'
     *
     * @param  int $id id (required)
     * @param  string $module_id moduleId (required)
     * @param  string $name Name of the module (required)
     * @param  int $index Index of the module.  Determines the order of the module in the email. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addModuleUsingPOSTRequest($id, $module_id, $name, $index)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling addModuleUsingPOST'
            );
        }
        // verify the required parameter 'module_id' is set
        if ($module_id === null || (is_array($module_id) && count($module_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $module_id when calling addModuleUsingPOST'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling addModuleUsingPOST'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling addModuleUsingPOST'
            );
        }

        $resourcePath = '/rest/asset/v1/email/{id}/content/{moduleId}/add.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($index !== null) {
            $queryParams['index'] = ObjectSerializer::toQueryValue($index);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($module_id !== null) {
            $resourcePath = str_replace(
                '{' . 'moduleId' . '}',
                ObjectSerializer::toPathValue($module_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation approveDraftUsingPOST
     *
     * Approve Email Draft
     *
     * @param  int $id id (required)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse
     */
    public function approveDraftUsingPOST($id)
    {
        list($response) = $this->approveDraftUsingPOSTWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation approveDraftUsingPOSTWithHttpInfo
     *
     * Approve Email Draft
     *
     * @param  int $id id (required)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function approveDraftUsingPOSTWithHttpInfo($id)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse';
        $request = $this->approveDraftUsingPOSTRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation approveDraftUsingPOSTAsync
     *
     * Approve Email Draft
     *
     * @param  int $id id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function approveDraftUsingPOSTAsync($id)
    {
        return $this->approveDraftUsingPOSTAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation approveDraftUsingPOSTAsyncWithHttpInfo
     *
     * Approve Email Draft
     *
     * @param  int $id id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function approveDraftUsingPOSTAsyncWithHttpInfo($id)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse';
        $request = $this->approveDraftUsingPOSTRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'approveDraftUsingPOST'
     *
     * @param  int $id id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function approveDraftUsingPOSTRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling approveDraftUsingPOST'
            );
        }

        $resourcePath = '/rest/asset/v1/email/{id}/approveDraft.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloneEmailUsingPOST
     *
     * Clone Email
     *
     * @param  int $id id (required)
     * @param  \NecLimDul\MarketoRest\Asset\Model\Folder $folder folder (required)
     * @param  string $name Name of the new email asset (required)
     * @param  string $description Description of the asset (optional)
     * @param  bool $operational Whether the email is operational.  Operational emails bypass unsubscribe status.  Defaults to false (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse
     */
    public function cloneEmailUsingPOST($id, $folder, $name, $description = null, $operational = null)
    {
        list($response) = $this->cloneEmailUsingPOSTWithHttpInfo($id, $folder, $name, $description, $operational);
        return $response;
    }

    /**
     * Operation cloneEmailUsingPOSTWithHttpInfo
     *
     * Clone Email
     *
     * @param  int $id id (required)
     * @param  \NecLimDul\MarketoRest\Asset\Model\Folder $folder (required)
     * @param  string $name Name of the new email asset (required)
     * @param  string $description Description of the asset (optional)
     * @param  bool $operational Whether the email is operational.  Operational emails bypass unsubscribe status.  Defaults to false (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloneEmailUsingPOSTWithHttpInfo($id, $folder, $name, $description = null, $operational = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse';
        $request = $this->cloneEmailUsingPOSTRequest($id, $folder, $name, $description, $operational);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloneEmailUsingPOSTAsync
     *
     * Clone Email
     *
     * @param  int $id id (required)
     * @param  \NecLimDul\MarketoRest\Asset\Model\Folder $folder (required)
     * @param  string $name Name of the new email asset (required)
     * @param  string $description Description of the asset (optional)
     * @param  bool $operational Whether the email is operational.  Operational emails bypass unsubscribe status.  Defaults to false (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloneEmailUsingPOSTAsync($id, $folder, $name, $description = null, $operational = null)
    {
        return $this->cloneEmailUsingPOSTAsyncWithHttpInfo($id, $folder, $name, $description, $operational)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloneEmailUsingPOSTAsyncWithHttpInfo
     *
     * Clone Email
     *
     * @param  int $id id (required)
     * @param  \NecLimDul\MarketoRest\Asset\Model\Folder $folder (required)
     * @param  string $name Name of the new email asset (required)
     * @param  string $description Description of the asset (optional)
     * @param  bool $operational Whether the email is operational.  Operational emails bypass unsubscribe status.  Defaults to false (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloneEmailUsingPOSTAsyncWithHttpInfo($id, $folder, $name, $description = null, $operational = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse';
        $request = $this->cloneEmailUsingPOSTRequest($id, $folder, $name, $description, $operational);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloneEmailUsingPOST'
     *
     * @param  int $id id (required)
     * @param  \NecLimDul\MarketoRest\Asset\Model\Folder $folder (required)
     * @param  string $name Name of the new email asset (required)
     * @param  string $description Description of the asset (optional)
     * @param  bool $operational Whether the email is operational.  Operational emails bypass unsubscribe status.  Defaults to false (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cloneEmailUsingPOSTRequest($id, $folder, $name, $description = null, $operational = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloneEmailUsingPOST'
            );
        }
        // verify the required parameter 'folder' is set
        if ($folder === null || (is_array($folder) && count($folder) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder when calling cloneEmailUsingPOST'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling cloneEmailUsingPOST'
            );
        }

        $resourcePath = '/rest/asset/v1/email/{id}/clone.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // form params
        if ($description !== null) {
            $formParams['description'] = ObjectSerializer::toFormValue($description);
        }
        // form params
        if ($folder !== null) {
            $formParams['folder'] = ObjectSerializer::toFormValue($folder);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($operational !== null) {
            $formParams['operational'] = ObjectSerializer::toFormValue($operational);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createEmailFullContentUsingPOST
     *
     * Update Email Full Content
     *
     * @param  int $id Id of the email (required)
     * @param  string $content Multipart file. File containing HTML document to update with.  File cannot include JavaScript or script tags. (required)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ResponseOfUpdateEmailFullContentResponse
     */
    public function createEmailFullContentUsingPOST($id, $content)
    {
        list($response) = $this->createEmailFullContentUsingPOSTWithHttpInfo($id, $content);
        return $response;
    }

    /**
     * Operation createEmailFullContentUsingPOSTWithHttpInfo
     *
     * Update Email Full Content
     *
     * @param  int $id Id of the email (required)
     * @param  string $content Multipart file. File containing HTML document to update with.  File cannot include JavaScript or script tags. (required)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ResponseOfUpdateEmailFullContentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createEmailFullContentUsingPOSTWithHttpInfo($id, $content)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfUpdateEmailFullContentResponse';
        $request = $this->createEmailFullContentUsingPOSTRequest($id, $content);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ResponseOfUpdateEmailFullContentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createEmailFullContentUsingPOSTAsync
     *
     * Update Email Full Content
     *
     * @param  int $id Id of the email (required)
     * @param  string $content Multipart file. File containing HTML document to update with.  File cannot include JavaScript or script tags. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEmailFullContentUsingPOSTAsync($id, $content)
    {
        return $this->createEmailFullContentUsingPOSTAsyncWithHttpInfo($id, $content)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createEmailFullContentUsingPOSTAsyncWithHttpInfo
     *
     * Update Email Full Content
     *
     * @param  int $id Id of the email (required)
     * @param  string $content Multipart file. File containing HTML document to update with.  File cannot include JavaScript or script tags. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEmailFullContentUsingPOSTAsyncWithHttpInfo($id, $content)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfUpdateEmailFullContentResponse';
        $request = $this->createEmailFullContentUsingPOSTRequest($id, $content);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createEmailFullContentUsingPOST'
     *
     * @param  int $id Id of the email (required)
     * @param  string $content Multipart file. File containing HTML document to update with.  File cannot include JavaScript or script tags. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createEmailFullContentUsingPOSTRequest($id, $content)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling createEmailFullContentUsingPOST'
            );
        }
        // verify the required parameter 'content' is set
        if ($content === null || (is_array($content) && count($content) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content when calling createEmailFullContentUsingPOST'
            );
        }

        $resourcePath = '/rest/asset/v1/email/{id}/fullContent.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // form params
        if ($content !== null) {
            $formParams['content'] = ObjectSerializer::toFormValue($content);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createEmailUsingPOST
     *
     * Create Email
     *
     * @param  \NecLimDul\MarketoRest\Asset\Model\Folder $folder folder (required)
     * @param  string $from_email From-address of the Email (required)
     * @param  string $from_name From-name of the Email (required)
     * @param  string $name Name of the email (required)
     * @param  string $reply_email Reply-To address of the Email (required)
     * @param  string $subject Subject Line of the Email (required)
     * @param  int $template Id of the parent template (required)
     * @param  string $description Description of the asset (optional)
     * @param  bool $operational Whether the email is operational.  Operational emails bypass unsubscribe status.  Defaults to false (optional)
     * @param  string $text_only Setting to include text-only version of email when sent (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse
     */
    public function createEmailUsingPOST($folder, $from_email, $from_name, $name, $reply_email, $subject, $template, $description = null, $operational = null, $text_only = null)
    {
        list($response) = $this->createEmailUsingPOSTWithHttpInfo($folder, $from_email, $from_name, $name, $reply_email, $subject, $template, $description, $operational, $text_only);
        return $response;
    }

    /**
     * Operation createEmailUsingPOSTWithHttpInfo
     *
     * Create Email
     *
     * @param  \NecLimDul\MarketoRest\Asset\Model\Folder $folder (required)
     * @param  string $from_email From-address of the Email (required)
     * @param  string $from_name From-name of the Email (required)
     * @param  string $name Name of the email (required)
     * @param  string $reply_email Reply-To address of the Email (required)
     * @param  string $subject Subject Line of the Email (required)
     * @param  int $template Id of the parent template (required)
     * @param  string $description Description of the asset (optional)
     * @param  bool $operational Whether the email is operational.  Operational emails bypass unsubscribe status.  Defaults to false (optional)
     * @param  string $text_only Setting to include text-only version of email when sent (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createEmailUsingPOSTWithHttpInfo($folder, $from_email, $from_name, $name, $reply_email, $subject, $template, $description = null, $operational = null, $text_only = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse';
        $request = $this->createEmailUsingPOSTRequest($folder, $from_email, $from_name, $name, $reply_email, $subject, $template, $description, $operational, $text_only);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createEmailUsingPOSTAsync
     *
     * Create Email
     *
     * @param  \NecLimDul\MarketoRest\Asset\Model\Folder $folder (required)
     * @param  string $from_email From-address of the Email (required)
     * @param  string $from_name From-name of the Email (required)
     * @param  string $name Name of the email (required)
     * @param  string $reply_email Reply-To address of the Email (required)
     * @param  string $subject Subject Line of the Email (required)
     * @param  int $template Id of the parent template (required)
     * @param  string $description Description of the asset (optional)
     * @param  bool $operational Whether the email is operational.  Operational emails bypass unsubscribe status.  Defaults to false (optional)
     * @param  string $text_only Setting to include text-only version of email when sent (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEmailUsingPOSTAsync($folder, $from_email, $from_name, $name, $reply_email, $subject, $template, $description = null, $operational = null, $text_only = null)
    {
        return $this->createEmailUsingPOSTAsyncWithHttpInfo($folder, $from_email, $from_name, $name, $reply_email, $subject, $template, $description, $operational, $text_only)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createEmailUsingPOSTAsyncWithHttpInfo
     *
     * Create Email
     *
     * @param  \NecLimDul\MarketoRest\Asset\Model\Folder $folder (required)
     * @param  string $from_email From-address of the Email (required)
     * @param  string $from_name From-name of the Email (required)
     * @param  string $name Name of the email (required)
     * @param  string $reply_email Reply-To address of the Email (required)
     * @param  string $subject Subject Line of the Email (required)
     * @param  int $template Id of the parent template (required)
     * @param  string $description Description of the asset (optional)
     * @param  bool $operational Whether the email is operational.  Operational emails bypass unsubscribe status.  Defaults to false (optional)
     * @param  string $text_only Setting to include text-only version of email when sent (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEmailUsingPOSTAsyncWithHttpInfo($folder, $from_email, $from_name, $name, $reply_email, $subject, $template, $description = null, $operational = null, $text_only = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse';
        $request = $this->createEmailUsingPOSTRequest($folder, $from_email, $from_name, $name, $reply_email, $subject, $template, $description, $operational, $text_only);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createEmailUsingPOST'
     *
     * @param  \NecLimDul\MarketoRest\Asset\Model\Folder $folder (required)
     * @param  string $from_email From-address of the Email (required)
     * @param  string $from_name From-name of the Email (required)
     * @param  string $name Name of the email (required)
     * @param  string $reply_email Reply-To address of the Email (required)
     * @param  string $subject Subject Line of the Email (required)
     * @param  int $template Id of the parent template (required)
     * @param  string $description Description of the asset (optional)
     * @param  bool $operational Whether the email is operational.  Operational emails bypass unsubscribe status.  Defaults to false (optional)
     * @param  string $text_only Setting to include text-only version of email when sent (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createEmailUsingPOSTRequest($folder, $from_email, $from_name, $name, $reply_email, $subject, $template, $description = null, $operational = null, $text_only = null)
    {
        // verify the required parameter 'folder' is set
        if ($folder === null || (is_array($folder) && count($folder) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder when calling createEmailUsingPOST'
            );
        }
        // verify the required parameter 'from_email' is set
        if ($from_email === null || (is_array($from_email) && count($from_email) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from_email when calling createEmailUsingPOST'
            );
        }
        // verify the required parameter 'from_name' is set
        if ($from_name === null || (is_array($from_name) && count($from_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from_name when calling createEmailUsingPOST'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling createEmailUsingPOST'
            );
        }
        // verify the required parameter 'reply_email' is set
        if ($reply_email === null || (is_array($reply_email) && count($reply_email) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reply_email when calling createEmailUsingPOST'
            );
        }
        // verify the required parameter 'subject' is set
        if ($subject === null || (is_array($subject) && count($subject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $subject when calling createEmailUsingPOST'
            );
        }
        // verify the required parameter 'template' is set
        if ($template === null || (is_array($template) && count($template) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template when calling createEmailUsingPOST'
            );
        }

        $resourcePath = '/rest/asset/v1/emails.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($description !== null) {
            $formParams['description'] = ObjectSerializer::toFormValue($description);
        }
        // form params
        if ($folder !== null) {
            $formParams['folder'] = ObjectSerializer::toFormValue($folder);
        }
        // form params
        if ($from_email !== null) {
            $formParams['fromEmail'] = ObjectSerializer::toFormValue($from_email);
        }
        // form params
        if ($from_name !== null) {
            $formParams['fromName'] = ObjectSerializer::toFormValue($from_name);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($operational !== null) {
            $formParams['operational'] = ObjectSerializer::toFormValue($operational);
        }
        // form params
        if ($reply_email !== null) {
            $formParams['replyEmail'] = ObjectSerializer::toFormValue($reply_email);
        }
        // form params
        if ($subject !== null) {
            $formParams['subject'] = ObjectSerializer::toFormValue($subject);
        }
        // form params
        if ($template !== null) {
            $formParams['template'] = ObjectSerializer::toFormValue($template);
        }
        // form params
        if ($text_only !== null) {
            $formParams['textOnly'] = ObjectSerializer::toFormValue($text_only);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteEmailUsingPOST
     *
     * Delete Email
     *
     * @param  int $id id (required)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse
     */
    public function deleteEmailUsingPOST($id)
    {
        list($response) = $this->deleteEmailUsingPOSTWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation deleteEmailUsingPOSTWithHttpInfo
     *
     * Delete Email
     *
     * @param  int $id id (required)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteEmailUsingPOSTWithHttpInfo($id)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse';
        $request = $this->deleteEmailUsingPOSTRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteEmailUsingPOSTAsync
     *
     * Delete Email
     *
     * @param  int $id id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteEmailUsingPOSTAsync($id)
    {
        return $this->deleteEmailUsingPOSTAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteEmailUsingPOSTAsyncWithHttpInfo
     *
     * Delete Email
     *
     * @param  int $id id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteEmailUsingPOSTAsyncWithHttpInfo($id)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse';
        $request = $this->deleteEmailUsingPOSTRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteEmailUsingPOST'
     *
     * @param  int $id id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteEmailUsingPOSTRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteEmailUsingPOST'
            );
        }

        $resourcePath = '/rest/asset/v1/email/{id}/delete.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteModuleUsingPOST
     *
     * Delete Module
     *
     * @param  int $id id (required)
     * @param  string $module_id moduleId (required)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ModelResponse
     */
    public function deleteModuleUsingPOST($id, $module_id)
    {
        list($response) = $this->deleteModuleUsingPOSTWithHttpInfo($id, $module_id);
        return $response;
    }

    /**
     * Operation deleteModuleUsingPOSTWithHttpInfo
     *
     * Delete Module
     *
     * @param  int $id id (required)
     * @param  string $module_id moduleId (required)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ModelResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteModuleUsingPOSTWithHttpInfo($id, $module_id)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ModelResponse';
        $request = $this->deleteModuleUsingPOSTRequest($id, $module_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ModelResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteModuleUsingPOSTAsync
     *
     * Delete Module
     *
     * @param  int $id id (required)
     * @param  string $module_id moduleId (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteModuleUsingPOSTAsync($id, $module_id)
    {
        return $this->deleteModuleUsingPOSTAsyncWithHttpInfo($id, $module_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteModuleUsingPOSTAsyncWithHttpInfo
     *
     * Delete Module
     *
     * @param  int $id id (required)
     * @param  string $module_id moduleId (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteModuleUsingPOSTAsyncWithHttpInfo($id, $module_id)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ModelResponse';
        $request = $this->deleteModuleUsingPOSTRequest($id, $module_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteModuleUsingPOST'
     *
     * @param  int $id id (required)
     * @param  string $module_id moduleId (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteModuleUsingPOSTRequest($id, $module_id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteModuleUsingPOST'
            );
        }
        // verify the required parameter 'module_id' is set
        if ($module_id === null || (is_array($module_id) && count($module_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $module_id when calling deleteModuleUsingPOST'
            );
        }

        $resourcePath = '/rest/asset/v1/email/{id}/content/{moduleId}/delete.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($module_id !== null) {
            $resourcePath = str_replace(
                '{' . 'moduleId' . '}',
                ObjectSerializer::toPathValue($module_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation discardDraftUsingPOST
     *
     * Discard Email Draft
     *
     * @param  int $id id (required)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse
     */
    public function discardDraftUsingPOST($id)
    {
        list($response) = $this->discardDraftUsingPOSTWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation discardDraftUsingPOSTWithHttpInfo
     *
     * Discard Email Draft
     *
     * @param  int $id id (required)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function discardDraftUsingPOSTWithHttpInfo($id)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse';
        $request = $this->discardDraftUsingPOSTRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation discardDraftUsingPOSTAsync
     *
     * Discard Email Draft
     *
     * @param  int $id id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function discardDraftUsingPOSTAsync($id)
    {
        return $this->discardDraftUsingPOSTAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation discardDraftUsingPOSTAsyncWithHttpInfo
     *
     * Discard Email Draft
     *
     * @param  int $id id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function discardDraftUsingPOSTAsyncWithHttpInfo($id)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse';
        $request = $this->discardDraftUsingPOSTRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'discardDraftUsingPOST'
     *
     * @param  int $id id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function discardDraftUsingPOSTRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling discardDraftUsingPOST'
            );
        }

        $resourcePath = '/rest/asset/v1/email/{id}/discardDraft.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation duplicateModuleUsingPOST
     *
     * Duplicate Email Module
     *
     * @param  int $id id (required)
     * @param  string $module_id moduleId (required)
     * @param  string $name Name of the new module (required)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ModelResponse
     */
    public function duplicateModuleUsingPOST($id, $module_id, $name)
    {
        list($response) = $this->duplicateModuleUsingPOSTWithHttpInfo($id, $module_id, $name);
        return $response;
    }

    /**
     * Operation duplicateModuleUsingPOSTWithHttpInfo
     *
     * Duplicate Email Module
     *
     * @param  int $id id (required)
     * @param  string $module_id moduleId (required)
     * @param  string $name Name of the new module (required)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ModelResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function duplicateModuleUsingPOSTWithHttpInfo($id, $module_id, $name)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ModelResponse';
        $request = $this->duplicateModuleUsingPOSTRequest($id, $module_id, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ModelResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation duplicateModuleUsingPOSTAsync
     *
     * Duplicate Email Module
     *
     * @param  int $id id (required)
     * @param  string $module_id moduleId (required)
     * @param  string $name Name of the new module (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function duplicateModuleUsingPOSTAsync($id, $module_id, $name)
    {
        return $this->duplicateModuleUsingPOSTAsyncWithHttpInfo($id, $module_id, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation duplicateModuleUsingPOSTAsyncWithHttpInfo
     *
     * Duplicate Email Module
     *
     * @param  int $id id (required)
     * @param  string $module_id moduleId (required)
     * @param  string $name Name of the new module (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function duplicateModuleUsingPOSTAsyncWithHttpInfo($id, $module_id, $name)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ModelResponse';
        $request = $this->duplicateModuleUsingPOSTRequest($id, $module_id, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'duplicateModuleUsingPOST'
     *
     * @param  int $id id (required)
     * @param  string $module_id moduleId (required)
     * @param  string $name Name of the new module (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function duplicateModuleUsingPOSTRequest($id, $module_id, $name)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling duplicateModuleUsingPOST'
            );
        }
        // verify the required parameter 'module_id' is set
        if ($module_id === null || (is_array($module_id) && count($module_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $module_id when calling duplicateModuleUsingPOST'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling duplicateModuleUsingPOST'
            );
        }

        $resourcePath = '/rest/asset/v1/email/{id}/content/{moduleId}/duplicate.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($module_id !== null) {
            $resourcePath = str_replace(
                '{' . 'moduleId' . '}',
                ObjectSerializer::toPathValue($module_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEmailByIdUsingGET
     *
     * Get Email By Id
     *
     * @param  int $id id (required)
     * @param  string $status Status filter for draft or approved versions (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse
     */
    public function getEmailByIdUsingGET($id, $status = null)
    {
        list($response) = $this->getEmailByIdUsingGETWithHttpInfo($id, $status);
        return $response;
    }

    /**
     * Operation getEmailByIdUsingGETWithHttpInfo
     *
     * Get Email By Id
     *
     * @param  int $id id (required)
     * @param  string $status Status filter for draft or approved versions (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEmailByIdUsingGETWithHttpInfo($id, $status = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse';
        $request = $this->getEmailByIdUsingGETRequest($id, $status);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEmailByIdUsingGETAsync
     *
     * Get Email By Id
     *
     * @param  int $id id (required)
     * @param  string $status Status filter for draft or approved versions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailByIdUsingGETAsync($id, $status = null)
    {
        return $this->getEmailByIdUsingGETAsyncWithHttpInfo($id, $status)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEmailByIdUsingGETAsyncWithHttpInfo
     *
     * Get Email By Id
     *
     * @param  int $id id (required)
     * @param  string $status Status filter for draft or approved versions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailByIdUsingGETAsyncWithHttpInfo($id, $status = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse';
        $request = $this->getEmailByIdUsingGETRequest($id, $status);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEmailByIdUsingGET'
     *
     * @param  int $id id (required)
     * @param  string $status Status filter for draft or approved versions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEmailByIdUsingGETRequest($id, $status = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getEmailByIdUsingGET'
            );
        }

        $resourcePath = '/rest/asset/v1/email/{id}.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEmailByNameUsingGET
     *
     * Get Email by Name
     *
     * @param  string $name Name of the email (required)
     * @param  string $status Status filter for draft or approved versions (optional)
     * @param  string $folder JSON representation of parent folder, with members &#39;id&#39;, and &#39;type&#39; which may be &#39;Folder&#39; or &#39;Program&#39; (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse
     */
    public function getEmailByNameUsingGET($name, $status = null, $folder = null)
    {
        list($response) = $this->getEmailByNameUsingGETWithHttpInfo($name, $status, $folder);
        return $response;
    }

    /**
     * Operation getEmailByNameUsingGETWithHttpInfo
     *
     * Get Email by Name
     *
     * @param  string $name Name of the email (required)
     * @param  string $status Status filter for draft or approved versions (optional)
     * @param  string $folder JSON representation of parent folder, with members &#39;id&#39;, and &#39;type&#39; which may be &#39;Folder&#39; or &#39;Program&#39; (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEmailByNameUsingGETWithHttpInfo($name, $status = null, $folder = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse';
        $request = $this->getEmailByNameUsingGETRequest($name, $status, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEmailByNameUsingGETAsync
     *
     * Get Email by Name
     *
     * @param  string $name Name of the email (required)
     * @param  string $status Status filter for draft or approved versions (optional)
     * @param  string $folder JSON representation of parent folder, with members &#39;id&#39;, and &#39;type&#39; which may be &#39;Folder&#39; or &#39;Program&#39; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailByNameUsingGETAsync($name, $status = null, $folder = null)
    {
        return $this->getEmailByNameUsingGETAsyncWithHttpInfo($name, $status, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEmailByNameUsingGETAsyncWithHttpInfo
     *
     * Get Email by Name
     *
     * @param  string $name Name of the email (required)
     * @param  string $status Status filter for draft or approved versions (optional)
     * @param  string $folder JSON representation of parent folder, with members &#39;id&#39;, and &#39;type&#39; which may be &#39;Folder&#39; or &#39;Program&#39; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailByNameUsingGETAsyncWithHttpInfo($name, $status = null, $folder = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse';
        $request = $this->getEmailByNameUsingGETRequest($name, $status, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEmailByNameUsingGET'
     *
     * @param  string $name Name of the email (required)
     * @param  string $status Status filter for draft or approved versions (optional)
     * @param  string $folder JSON representation of parent folder, with members &#39;id&#39;, and &#39;type&#39; which may be &#39;Folder&#39; or &#39;Program&#39; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEmailByNameUsingGETRequest($name, $status = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getEmailByNameUsingGET'
            );
        }

        $resourcePath = '/rest/asset/v1/email/byName.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEmailCCFieldsUsingGET
     *
     * Get Email CC Fields
     *
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailCCFieldsResponse
     */
    public function getEmailCCFieldsUsingGET()
    {
        list($response) = $this->getEmailCCFieldsUsingGETWithHttpInfo();
        return $response;
    }

    /**
     * Operation getEmailCCFieldsUsingGETWithHttpInfo
     *
     * Get Email CC Fields
     *
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailCCFieldsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEmailCCFieldsUsingGETWithHttpInfo()
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailCCFieldsResponse';
        $request = $this->getEmailCCFieldsUsingGETRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailCCFieldsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEmailCCFieldsUsingGETAsync
     *
     * Get Email CC Fields
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailCCFieldsUsingGETAsync()
    {
        return $this->getEmailCCFieldsUsingGETAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEmailCCFieldsUsingGETAsyncWithHttpInfo
     *
     * Get Email CC Fields
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailCCFieldsUsingGETAsyncWithHttpInfo()
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailCCFieldsResponse';
        $request = $this->getEmailCCFieldsUsingGETRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEmailCCFieldsUsingGET'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEmailCCFieldsUsingGETRequest()
    {

        $resourcePath = '/rest/asset/v1/email/ccFields.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEmailContentByIdUsingGET
     *
     * Get Email Content
     *
     * @param  int $id id (required)
     * @param  string $status Status filter for draft or approved versions (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailContentResponse
     */
    public function getEmailContentByIdUsingGET($id, $status = null)
    {
        list($response) = $this->getEmailContentByIdUsingGETWithHttpInfo($id, $status);
        return $response;
    }

    /**
     * Operation getEmailContentByIdUsingGETWithHttpInfo
     *
     * Get Email Content
     *
     * @param  int $id id (required)
     * @param  string $status Status filter for draft or approved versions (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailContentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEmailContentByIdUsingGETWithHttpInfo($id, $status = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailContentResponse';
        $request = $this->getEmailContentByIdUsingGETRequest($id, $status);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailContentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEmailContentByIdUsingGETAsync
     *
     * Get Email Content
     *
     * @param  int $id id (required)
     * @param  string $status Status filter for draft or approved versions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailContentByIdUsingGETAsync($id, $status = null)
    {
        return $this->getEmailContentByIdUsingGETAsyncWithHttpInfo($id, $status)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEmailContentByIdUsingGETAsyncWithHttpInfo
     *
     * Get Email Content
     *
     * @param  int $id id (required)
     * @param  string $status Status filter for draft or approved versions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailContentByIdUsingGETAsyncWithHttpInfo($id, $status = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailContentResponse';
        $request = $this->getEmailContentByIdUsingGETRequest($id, $status);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEmailContentByIdUsingGET'
     *
     * @param  int $id id (required)
     * @param  string $status Status filter for draft or approved versions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEmailContentByIdUsingGETRequest($id, $status = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getEmailContentByIdUsingGET'
            );
        }

        $resourcePath = '/rest/asset/v1/email/{id}/content.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEmailDynamicContentUsingGET
     *
     * Get Email Dynamic Content
     *
     * @param  int $id Id of email (required)
     * @param  string $content_id Id of email dynamic content section (required)
     * @param  string $status Status filter for draft or approved versions (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailDynamicContentResponse
     */
    public function getEmailDynamicContentUsingGET($id, $content_id, $status = null)
    {
        list($response) = $this->getEmailDynamicContentUsingGETWithHttpInfo($id, $content_id, $status);
        return $response;
    }

    /**
     * Operation getEmailDynamicContentUsingGETWithHttpInfo
     *
     * Get Email Dynamic Content
     *
     * @param  int $id Id of email (required)
     * @param  string $content_id Id of email dynamic content section (required)
     * @param  string $status Status filter for draft or approved versions (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailDynamicContentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEmailDynamicContentUsingGETWithHttpInfo($id, $content_id, $status = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailDynamicContentResponse';
        $request = $this->getEmailDynamicContentUsingGETRequest($id, $content_id, $status);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailDynamicContentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEmailDynamicContentUsingGETAsync
     *
     * Get Email Dynamic Content
     *
     * @param  int $id Id of email (required)
     * @param  string $content_id Id of email dynamic content section (required)
     * @param  string $status Status filter for draft or approved versions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailDynamicContentUsingGETAsync($id, $content_id, $status = null)
    {
        return $this->getEmailDynamicContentUsingGETAsyncWithHttpInfo($id, $content_id, $status)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEmailDynamicContentUsingGETAsyncWithHttpInfo
     *
     * Get Email Dynamic Content
     *
     * @param  int $id Id of email (required)
     * @param  string $content_id Id of email dynamic content section (required)
     * @param  string $status Status filter for draft or approved versions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailDynamicContentUsingGETAsyncWithHttpInfo($id, $content_id, $status = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailDynamicContentResponse';
        $request = $this->getEmailDynamicContentUsingGETRequest($id, $content_id, $status);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEmailDynamicContentUsingGET'
     *
     * @param  int $id Id of email (required)
     * @param  string $content_id Id of email dynamic content section (required)
     * @param  string $status Status filter for draft or approved versions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEmailDynamicContentUsingGETRequest($id, $content_id, $status = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getEmailDynamicContentUsingGET'
            );
        }
        // verify the required parameter 'content_id' is set
        if ($content_id === null || (is_array($content_id) && count($content_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_id when calling getEmailDynamicContentUsingGET'
            );
        }

        $resourcePath = '/rest/asset/v1/email/{id}/dynamicContent/{contentId}.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($content_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contentId' . '}',
                ObjectSerializer::toPathValue($content_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEmailFullContentUsingGET
     *
     * Get Email Full Content
     *
     * @param  int $id Id of the email (required)
     * @param  string $status Status filter for draft or approved versions.  Defaults to approved if asset is approved, draft if not. (optional)
     * @param  int $lead_id The lead id to impersonate.  Email is rendered as though it was received by this lead. (optional)
     * @param  string $type Email content type to return.  Default is HTML. (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ResponseOfGetEmailFullContentResponse
     */
    public function getEmailFullContentUsingGET($id, $status = null, $lead_id = null, $type = null)
    {
        list($response) = $this->getEmailFullContentUsingGETWithHttpInfo($id, $status, $lead_id, $type);
        return $response;
    }

    /**
     * Operation getEmailFullContentUsingGETWithHttpInfo
     *
     * Get Email Full Content
     *
     * @param  int $id Id of the email (required)
     * @param  string $status Status filter for draft or approved versions.  Defaults to approved if asset is approved, draft if not. (optional)
     * @param  int $lead_id The lead id to impersonate.  Email is rendered as though it was received by this lead. (optional)
     * @param  string $type Email content type to return.  Default is HTML. (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ResponseOfGetEmailFullContentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEmailFullContentUsingGETWithHttpInfo($id, $status = null, $lead_id = null, $type = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfGetEmailFullContentResponse';
        $request = $this->getEmailFullContentUsingGETRequest($id, $status, $lead_id, $type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ResponseOfGetEmailFullContentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEmailFullContentUsingGETAsync
     *
     * Get Email Full Content
     *
     * @param  int $id Id of the email (required)
     * @param  string $status Status filter for draft or approved versions.  Defaults to approved if asset is approved, draft if not. (optional)
     * @param  int $lead_id The lead id to impersonate.  Email is rendered as though it was received by this lead. (optional)
     * @param  string $type Email content type to return.  Default is HTML. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailFullContentUsingGETAsync($id, $status = null, $lead_id = null, $type = null)
    {
        return $this->getEmailFullContentUsingGETAsyncWithHttpInfo($id, $status, $lead_id, $type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEmailFullContentUsingGETAsyncWithHttpInfo
     *
     * Get Email Full Content
     *
     * @param  int $id Id of the email (required)
     * @param  string $status Status filter for draft or approved versions.  Defaults to approved if asset is approved, draft if not. (optional)
     * @param  int $lead_id The lead id to impersonate.  Email is rendered as though it was received by this lead. (optional)
     * @param  string $type Email content type to return.  Default is HTML. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailFullContentUsingGETAsyncWithHttpInfo($id, $status = null, $lead_id = null, $type = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfGetEmailFullContentResponse';
        $request = $this->getEmailFullContentUsingGETRequest($id, $status, $lead_id, $type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEmailFullContentUsingGET'
     *
     * @param  int $id Id of the email (required)
     * @param  string $status Status filter for draft or approved versions.  Defaults to approved if asset is approved, draft if not. (optional)
     * @param  int $lead_id The lead id to impersonate.  Email is rendered as though it was received by this lead. (optional)
     * @param  string $type Email content type to return.  Default is HTML. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEmailFullContentUsingGETRequest($id, $status = null, $lead_id = null, $type = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getEmailFullContentUsingGET'
            );
        }

        $resourcePath = '/rest/asset/v1/email/{id}/fullContent.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($lead_id !== null) {
            $queryParams['leadId'] = ObjectSerializer::toQueryValue($lead_id);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEmailUsingGET
     *
     * Get Emails
     *
     * @param  string $status Status filter for draft or approved versions (optional)
     * @param  string $folder JSON representation of parent folder, with members &#39;id&#39;, and &#39;type&#39; which may be &#39;Folder&#39; or &#39;Program&#39; (optional)
     * @param  int $offset Integer offset for paging (optional)
     * @param  int $max_return Maximum number of emails to return.  Max 200, default 20 (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse
     */
    public function getEmailUsingGET($status = null, $folder = null, $offset = null, $max_return = null)
    {
        list($response) = $this->getEmailUsingGETWithHttpInfo($status, $folder, $offset, $max_return);
        return $response;
    }

    /**
     * Operation getEmailUsingGETWithHttpInfo
     *
     * Get Emails
     *
     * @param  string $status Status filter for draft or approved versions (optional)
     * @param  string $folder JSON representation of parent folder, with members &#39;id&#39;, and &#39;type&#39; which may be &#39;Folder&#39; or &#39;Program&#39; (optional)
     * @param  int $offset Integer offset for paging (optional)
     * @param  int $max_return Maximum number of emails to return.  Max 200, default 20 (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEmailUsingGETWithHttpInfo($status = null, $folder = null, $offset = null, $max_return = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse';
        $request = $this->getEmailUsingGETRequest($status, $folder, $offset, $max_return);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEmailUsingGETAsync
     *
     * Get Emails
     *
     * @param  string $status Status filter for draft or approved versions (optional)
     * @param  string $folder JSON representation of parent folder, with members &#39;id&#39;, and &#39;type&#39; which may be &#39;Folder&#39; or &#39;Program&#39; (optional)
     * @param  int $offset Integer offset for paging (optional)
     * @param  int $max_return Maximum number of emails to return.  Max 200, default 20 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailUsingGETAsync($status = null, $folder = null, $offset = null, $max_return = null)
    {
        return $this->getEmailUsingGETAsyncWithHttpInfo($status, $folder, $offset, $max_return)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEmailUsingGETAsyncWithHttpInfo
     *
     * Get Emails
     *
     * @param  string $status Status filter for draft or approved versions (optional)
     * @param  string $folder JSON representation of parent folder, with members &#39;id&#39;, and &#39;type&#39; which may be &#39;Folder&#39; or &#39;Program&#39; (optional)
     * @param  int $offset Integer offset for paging (optional)
     * @param  int $max_return Maximum number of emails to return.  Max 200, default 20 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailUsingGETAsyncWithHttpInfo($status = null, $folder = null, $offset = null, $max_return = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse';
        $request = $this->getEmailUsingGETRequest($status, $folder, $offset, $max_return);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEmailUsingGET'
     *
     * @param  string $status Status filter for draft or approved versions (optional)
     * @param  string $folder JSON representation of parent folder, with members &#39;id&#39;, and &#39;type&#39; which may be &#39;Folder&#39; or &#39;Program&#39; (optional)
     * @param  int $offset Integer offset for paging (optional)
     * @param  int $max_return Maximum number of emails to return.  Max 200, default 20 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEmailUsingGETRequest($status = null, $folder = null, $offset = null, $max_return = null)
    {

        $resourcePath = '/rest/asset/v1/emails.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($max_return !== null) {
            $queryParams['maxReturn'] = ObjectSerializer::toQueryValue($max_return);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEmailVariablesUsingGET
     *
     * Get Email Variables
     *
     * @param  int $id id (required)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ModelResponse
     */
    public function getEmailVariablesUsingGET($id)
    {
        list($response) = $this->getEmailVariablesUsingGETWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getEmailVariablesUsingGETWithHttpInfo
     *
     * Get Email Variables
     *
     * @param  int $id id (required)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ModelResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEmailVariablesUsingGETWithHttpInfo($id)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ModelResponse';
        $request = $this->getEmailVariablesUsingGETRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ModelResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEmailVariablesUsingGETAsync
     *
     * Get Email Variables
     *
     * @param  int $id id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailVariablesUsingGETAsync($id)
    {
        return $this->getEmailVariablesUsingGETAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEmailVariablesUsingGETAsyncWithHttpInfo
     *
     * Get Email Variables
     *
     * @param  int $id id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailVariablesUsingGETAsyncWithHttpInfo($id)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ModelResponse';
        $request = $this->getEmailVariablesUsingGETRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEmailVariablesUsingGET'
     *
     * @param  int $id id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEmailVariablesUsingGETRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getEmailVariablesUsingGET'
            );
        }

        $resourcePath = '/rest/asset/v1/email/{id}/variables.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rearrangeModulesUsingPOST
     *
     * Rearrange Email Modules
     *
     * @param  int $id id (required)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ModelResponse
     */
    public function rearrangeModulesUsingPOST($id)
    {
        list($response) = $this->rearrangeModulesUsingPOSTWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation rearrangeModulesUsingPOSTWithHttpInfo
     *
     * Rearrange Email Modules
     *
     * @param  int $id id (required)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ModelResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function rearrangeModulesUsingPOSTWithHttpInfo($id)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ModelResponse';
        $request = $this->rearrangeModulesUsingPOSTRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ModelResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation rearrangeModulesUsingPOSTAsync
     *
     * Rearrange Email Modules
     *
     * @param  int $id id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rearrangeModulesUsingPOSTAsync($id)
    {
        return $this->rearrangeModulesUsingPOSTAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rearrangeModulesUsingPOSTAsyncWithHttpInfo
     *
     * Rearrange Email Modules
     *
     * @param  int $id id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rearrangeModulesUsingPOSTAsyncWithHttpInfo($id)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ModelResponse';
        $request = $this->rearrangeModulesUsingPOSTRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rearrangeModulesUsingPOST'
     *
     * @param  int $id id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rearrangeModulesUsingPOSTRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling rearrangeModulesUsingPOST'
            );
        }

        $resourcePath = '/rest/asset/v1/email/{id}/content/rearrange.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation renameUsingPOST
     *
     * Rename Email Module
     *
     * @param  int $id id (required)
     * @param  string $module_id moduleId (required)
     * @param  string $name New module name (required)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ModelResponse
     */
    public function renameUsingPOST($id, $module_id, $name)
    {
        list($response) = $this->renameUsingPOSTWithHttpInfo($id, $module_id, $name);
        return $response;
    }

    /**
     * Operation renameUsingPOSTWithHttpInfo
     *
     * Rename Email Module
     *
     * @param  int $id id (required)
     * @param  string $module_id moduleId (required)
     * @param  string $name New module name (required)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ModelResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function renameUsingPOSTWithHttpInfo($id, $module_id, $name)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ModelResponse';
        $request = $this->renameUsingPOSTRequest($id, $module_id, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ModelResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation renameUsingPOSTAsync
     *
     * Rename Email Module
     *
     * @param  int $id id (required)
     * @param  string $module_id moduleId (required)
     * @param  string $name New module name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renameUsingPOSTAsync($id, $module_id, $name)
    {
        return $this->renameUsingPOSTAsyncWithHttpInfo($id, $module_id, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation renameUsingPOSTAsyncWithHttpInfo
     *
     * Rename Email Module
     *
     * @param  int $id id (required)
     * @param  string $module_id moduleId (required)
     * @param  string $name New module name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renameUsingPOSTAsyncWithHttpInfo($id, $module_id, $name)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ModelResponse';
        $request = $this->renameUsingPOSTRequest($id, $module_id, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'renameUsingPOST'
     *
     * @param  int $id id (required)
     * @param  string $module_id moduleId (required)
     * @param  string $name New module name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function renameUsingPOSTRequest($id, $module_id, $name)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling renameUsingPOST'
            );
        }
        // verify the required parameter 'module_id' is set
        if ($module_id === null || (is_array($module_id) && count($module_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $module_id when calling renameUsingPOST'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling renameUsingPOST'
            );
        }

        $resourcePath = '/rest/asset/v1/email/{id}/content/{moduleId}/rename.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($module_id !== null) {
            $resourcePath = str_replace(
                '{' . 'moduleId' . '}',
                ObjectSerializer::toPathValue($module_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendSampleEmailUsingPOST
     *
     * Send Sample Email
     *
     * @param  int $id Id of the email (required)
     * @param  string $email_address Email address to receive sample email (required)
     * @param  string $lead_id Id of a lead to impersonate.  Tokens and dynamic content will be populated as though it were sent to the lead. (optional)
     * @param  bool $text_only Whether to send to text only version along with the HTML version.  Default false. (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse
     */
    public function sendSampleEmailUsingPOST($id, $email_address, $lead_id = null, $text_only = null)
    {
        list($response) = $this->sendSampleEmailUsingPOSTWithHttpInfo($id, $email_address, $lead_id, $text_only);
        return $response;
    }

    /**
     * Operation sendSampleEmailUsingPOSTWithHttpInfo
     *
     * Send Sample Email
     *
     * @param  int $id Id of the email (required)
     * @param  string $email_address Email address to receive sample email (required)
     * @param  string $lead_id Id of a lead to impersonate.  Tokens and dynamic content will be populated as though it were sent to the lead. (optional)
     * @param  bool $text_only Whether to send to text only version along with the HTML version.  Default false. (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendSampleEmailUsingPOSTWithHttpInfo($id, $email_address, $lead_id = null, $text_only = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse';
        $request = $this->sendSampleEmailUsingPOSTRequest($id, $email_address, $lead_id, $text_only);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendSampleEmailUsingPOSTAsync
     *
     * Send Sample Email
     *
     * @param  int $id Id of the email (required)
     * @param  string $email_address Email address to receive sample email (required)
     * @param  string $lead_id Id of a lead to impersonate.  Tokens and dynamic content will be populated as though it were sent to the lead. (optional)
     * @param  bool $text_only Whether to send to text only version along with the HTML version.  Default false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendSampleEmailUsingPOSTAsync($id, $email_address, $lead_id = null, $text_only = null)
    {
        return $this->sendSampleEmailUsingPOSTAsyncWithHttpInfo($id, $email_address, $lead_id, $text_only)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendSampleEmailUsingPOSTAsyncWithHttpInfo
     *
     * Send Sample Email
     *
     * @param  int $id Id of the email (required)
     * @param  string $email_address Email address to receive sample email (required)
     * @param  string $lead_id Id of a lead to impersonate.  Tokens and dynamic content will be populated as though it were sent to the lead. (optional)
     * @param  bool $text_only Whether to send to text only version along with the HTML version.  Default false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendSampleEmailUsingPOSTAsyncWithHttpInfo($id, $email_address, $lead_id = null, $text_only = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse';
        $request = $this->sendSampleEmailUsingPOSTRequest($id, $email_address, $lead_id, $text_only);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendSampleEmailUsingPOST'
     *
     * @param  int $id Id of the email (required)
     * @param  string $email_address Email address to receive sample email (required)
     * @param  string $lead_id Id of a lead to impersonate.  Tokens and dynamic content will be populated as though it were sent to the lead. (optional)
     * @param  bool $text_only Whether to send to text only version along with the HTML version.  Default false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sendSampleEmailUsingPOSTRequest($id, $email_address, $lead_id = null, $text_only = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling sendSampleEmailUsingPOST'
            );
        }
        // verify the required parameter 'email_address' is set
        if ($email_address === null || (is_array($email_address) && count($email_address) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $email_address when calling sendSampleEmailUsingPOST'
            );
        }

        $resourcePath = '/rest/asset/v1/email/{id}/sendSample.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // form params
        if ($email_address !== null) {
            $formParams['emailAddress'] = ObjectSerializer::toFormValue($email_address);
        }
        // form params
        if ($lead_id !== null) {
            $formParams['leadId'] = ObjectSerializer::toFormValue($lead_id);
        }
        // form params
        if ($text_only !== null) {
            $formParams['textOnly'] = ObjectSerializer::toFormValue($text_only);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unapproveDraftUsingPOST
     *
     * Unapprove Email
     *
     * @param  int $id id (required)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse
     */
    public function unapproveDraftUsingPOST($id)
    {
        list($response) = $this->unapproveDraftUsingPOSTWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation unapproveDraftUsingPOSTWithHttpInfo
     *
     * Unapprove Email
     *
     * @param  int $id id (required)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function unapproveDraftUsingPOSTWithHttpInfo($id)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse';
        $request = $this->unapproveDraftUsingPOSTRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation unapproveDraftUsingPOSTAsync
     *
     * Unapprove Email
     *
     * @param  int $id id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unapproveDraftUsingPOSTAsync($id)
    {
        return $this->unapproveDraftUsingPOSTAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unapproveDraftUsingPOSTAsyncWithHttpInfo
     *
     * Unapprove Email
     *
     * @param  int $id id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unapproveDraftUsingPOSTAsyncWithHttpInfo($id)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse';
        $request = $this->unapproveDraftUsingPOSTRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unapproveDraftUsingPOST'
     *
     * @param  int $id id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function unapproveDraftUsingPOSTRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling unapproveDraftUsingPOST'
            );
        }

        $resourcePath = '/rest/asset/v1/email/{id}/unapprove.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateEmailComponentContentUsingPOST
     *
     * Update Email Content Section
     *
     * @param  int $id id (required)
     * @param  string $html_id htmlId (required)
     * @param  string $type Type of content to set for the section. (required)
     * @param  string $value Value to set for the section.  For type Text, the HTML content of the section.  For type DynamicContent, the id of the segmentation to use for the content.  For type Snippet, the id of the snippet to embed (required)
     * @param  string $alt_text Sets the value of the alt parameter for the resulting img element (optional)
     * @param  string $external_url external_url (optional)
     * @param  int $height Overrides naitve height of the image.  The resulting file will be resized to the given height (optional)
     * @param  string $image Multipart file that allows you to load an image from your computer (optional)
     * @param  string $link_url link_url (optional)
     * @param  bool $over_write Allows overwriting of the existing image content section (optional)
     * @param  string $style Sets the value of the style parameter for the content section (optional)
     * @param  string $text_value text_value (optional)
     * @param  string $video_url Sets the Url of the video element.  Videos must be either from YouTube or Vimeo (optional)
     * @param  int $width Overrides native width of the image.  The resulting file will be resized to the given width (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse
     */
    public function updateEmailComponentContentUsingPOST($id, $html_id, $type, $value, $alt_text = null, $external_url = null, $height = null, $image = null, $link_url = null, $over_write = null, $style = null, $text_value = null, $video_url = null, $width = null)
    {
        list($response) = $this->updateEmailComponentContentUsingPOSTWithHttpInfo($id, $html_id, $type, $value, $alt_text, $external_url, $height, $image, $link_url, $over_write, $style, $text_value, $video_url, $width);
        return $response;
    }

    /**
     * Operation updateEmailComponentContentUsingPOSTWithHttpInfo
     *
     * Update Email Content Section
     *
     * @param  int $id id (required)
     * @param  string $html_id htmlId (required)
     * @param  string $type Type of content to set for the section. (required)
     * @param  string $value Value to set for the section.  For type Text, the HTML content of the section.  For type DynamicContent, the id of the segmentation to use for the content.  For type Snippet, the id of the snippet to embed (required)
     * @param  string $alt_text Sets the value of the alt parameter for the resulting img element (optional)
     * @param  string $external_url (optional)
     * @param  int $height Overrides naitve height of the image.  The resulting file will be resized to the given height (optional)
     * @param  string $image Multipart file that allows you to load an image from your computer (optional)
     * @param  string $link_url (optional)
     * @param  bool $over_write Allows overwriting of the existing image content section (optional)
     * @param  string $style Sets the value of the style parameter for the content section (optional)
     * @param  string $text_value (optional)
     * @param  string $video_url Sets the Url of the video element.  Videos must be either from YouTube or Vimeo (optional)
     * @param  int $width Overrides native width of the image.  The resulting file will be resized to the given width (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateEmailComponentContentUsingPOSTWithHttpInfo($id, $html_id, $type, $value, $alt_text = null, $external_url = null, $height = null, $image = null, $link_url = null, $over_write = null, $style = null, $text_value = null, $video_url = null, $width = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse';
        $request = $this->updateEmailComponentContentUsingPOSTRequest($id, $html_id, $type, $value, $alt_text, $external_url, $height, $image, $link_url, $over_write, $style, $text_value, $video_url, $width);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateEmailComponentContentUsingPOSTAsync
     *
     * Update Email Content Section
     *
     * @param  int $id id (required)
     * @param  string $html_id htmlId (required)
     * @param  string $type Type of content to set for the section. (required)
     * @param  string $value Value to set for the section.  For type Text, the HTML content of the section.  For type DynamicContent, the id of the segmentation to use for the content.  For type Snippet, the id of the snippet to embed (required)
     * @param  string $alt_text Sets the value of the alt parameter for the resulting img element (optional)
     * @param  string $external_url (optional)
     * @param  int $height Overrides naitve height of the image.  The resulting file will be resized to the given height (optional)
     * @param  string $image Multipart file that allows you to load an image from your computer (optional)
     * @param  string $link_url (optional)
     * @param  bool $over_write Allows overwriting of the existing image content section (optional)
     * @param  string $style Sets the value of the style parameter for the content section (optional)
     * @param  string $text_value (optional)
     * @param  string $video_url Sets the Url of the video element.  Videos must be either from YouTube or Vimeo (optional)
     * @param  int $width Overrides native width of the image.  The resulting file will be resized to the given width (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEmailComponentContentUsingPOSTAsync($id, $html_id, $type, $value, $alt_text = null, $external_url = null, $height = null, $image = null, $link_url = null, $over_write = null, $style = null, $text_value = null, $video_url = null, $width = null)
    {
        return $this->updateEmailComponentContentUsingPOSTAsyncWithHttpInfo($id, $html_id, $type, $value, $alt_text, $external_url, $height, $image, $link_url, $over_write, $style, $text_value, $video_url, $width)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateEmailComponentContentUsingPOSTAsyncWithHttpInfo
     *
     * Update Email Content Section
     *
     * @param  int $id id (required)
     * @param  string $html_id htmlId (required)
     * @param  string $type Type of content to set for the section. (required)
     * @param  string $value Value to set for the section.  For type Text, the HTML content of the section.  For type DynamicContent, the id of the segmentation to use for the content.  For type Snippet, the id of the snippet to embed (required)
     * @param  string $alt_text Sets the value of the alt parameter for the resulting img element (optional)
     * @param  string $external_url (optional)
     * @param  int $height Overrides naitve height of the image.  The resulting file will be resized to the given height (optional)
     * @param  string $image Multipart file that allows you to load an image from your computer (optional)
     * @param  string $link_url (optional)
     * @param  bool $over_write Allows overwriting of the existing image content section (optional)
     * @param  string $style Sets the value of the style parameter for the content section (optional)
     * @param  string $text_value (optional)
     * @param  string $video_url Sets the Url of the video element.  Videos must be either from YouTube or Vimeo (optional)
     * @param  int $width Overrides native width of the image.  The resulting file will be resized to the given width (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEmailComponentContentUsingPOSTAsyncWithHttpInfo($id, $html_id, $type, $value, $alt_text = null, $external_url = null, $height = null, $image = null, $link_url = null, $over_write = null, $style = null, $text_value = null, $video_url = null, $width = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse';
        $request = $this->updateEmailComponentContentUsingPOSTRequest($id, $html_id, $type, $value, $alt_text, $external_url, $height, $image, $link_url, $over_write, $style, $text_value, $video_url, $width);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateEmailComponentContentUsingPOST'
     *
     * @param  int $id id (required)
     * @param  string $html_id htmlId (required)
     * @param  string $type Type of content to set for the section. (required)
     * @param  string $value Value to set for the section.  For type Text, the HTML content of the section.  For type DynamicContent, the id of the segmentation to use for the content.  For type Snippet, the id of the snippet to embed (required)
     * @param  string $alt_text Sets the value of the alt parameter for the resulting img element (optional)
     * @param  string $external_url (optional)
     * @param  int $height Overrides naitve height of the image.  The resulting file will be resized to the given height (optional)
     * @param  string $image Multipart file that allows you to load an image from your computer (optional)
     * @param  string $link_url (optional)
     * @param  bool $over_write Allows overwriting of the existing image content section (optional)
     * @param  string $style Sets the value of the style parameter for the content section (optional)
     * @param  string $text_value (optional)
     * @param  string $video_url Sets the Url of the video element.  Videos must be either from YouTube or Vimeo (optional)
     * @param  int $width Overrides native width of the image.  The resulting file will be resized to the given width (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateEmailComponentContentUsingPOSTRequest($id, $html_id, $type, $value, $alt_text = null, $external_url = null, $height = null, $image = null, $link_url = null, $over_write = null, $style = null, $text_value = null, $video_url = null, $width = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateEmailComponentContentUsingPOST'
            );
        }
        // verify the required parameter 'html_id' is set
        if ($html_id === null || (is_array($html_id) && count($html_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $html_id when calling updateEmailComponentContentUsingPOST'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling updateEmailComponentContentUsingPOST'
            );
        }
        // verify the required parameter 'value' is set
        if ($value === null || (is_array($value) && count($value) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $value when calling updateEmailComponentContentUsingPOST'
            );
        }

        $resourcePath = '/rest/asset/v1/email/{id}/content/{htmlId}.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($html_id !== null) {
            $resourcePath = str_replace(
                '{' . 'htmlId' . '}',
                ObjectSerializer::toPathValue($html_id),
                $resourcePath
            );
        }

        // form params
        if ($alt_text !== null) {
            $formParams['altText'] = ObjectSerializer::toFormValue($alt_text);
        }
        // form params
        if ($external_url !== null) {
            $formParams['externalUrl'] = ObjectSerializer::toFormValue($external_url);
        }
        // form params
        if ($height !== null) {
            $formParams['height'] = ObjectSerializer::toFormValue($height);
        }
        // form params
        if ($image !== null) {
            $formParams['image'] = ObjectSerializer::toFormValue($image);
        }
        // form params
        if ($link_url !== null) {
            $formParams['linkUrl'] = ObjectSerializer::toFormValue($link_url);
        }
        // form params
        if ($over_write !== null) {
            $formParams['overWrite'] = ObjectSerializer::toFormValue($over_write);
        }
        // form params
        if ($style !== null) {
            $formParams['style'] = ObjectSerializer::toFormValue($style);
        }
        // form params
        if ($text_value !== null) {
            $formParams['textValue'] = ObjectSerializer::toFormValue($text_value);
        }
        // form params
        if ($type !== null) {
            $formParams['type'] = ObjectSerializer::toFormValue($type);
        }
        // form params
        if ($value !== null) {
            $formParams['value'] = ObjectSerializer::toFormValue($value);
        }
        // form params
        if ($video_url !== null) {
            $formParams['videoUrl'] = ObjectSerializer::toFormValue($video_url);
        }
        // form params
        if ($width !== null) {
            $formParams['width'] = ObjectSerializer::toFormValue($width);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateEmailContentUsingPOST
     *
     * Update Email Content
     *
     * @param  int $id id (required)
     * @param  \NecLimDul\MarketoRest\Asset\Model\EmailHeaderTypeValue $from_email from_email (optional)
     * @param  \NecLimDul\MarketoRest\Asset\Model\EmailHeaderTypeValue $from_name from_name (optional)
     * @param  \NecLimDul\MarketoRest\Asset\Model\EmailHeaderTypeValue $reply_to reply_to (optional)
     * @param  \NecLimDul\MarketoRest\Asset\Model\EmailHeaderTypeValue $subject subject (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse
     */
    public function updateEmailContentUsingPOST($id, $from_email = null, $from_name = null, $reply_to = null, $subject = null)
    {
        list($response) = $this->updateEmailContentUsingPOSTWithHttpInfo($id, $from_email, $from_name, $reply_to, $subject);
        return $response;
    }

    /**
     * Operation updateEmailContentUsingPOSTWithHttpInfo
     *
     * Update Email Content
     *
     * @param  int $id id (required)
     * @param  \NecLimDul\MarketoRest\Asset\Model\EmailHeaderTypeValue $from_email (optional)
     * @param  \NecLimDul\MarketoRest\Asset\Model\EmailHeaderTypeValue $from_name (optional)
     * @param  \NecLimDul\MarketoRest\Asset\Model\EmailHeaderTypeValue $reply_to (optional)
     * @param  \NecLimDul\MarketoRest\Asset\Model\EmailHeaderTypeValue $subject (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateEmailContentUsingPOSTWithHttpInfo($id, $from_email = null, $from_name = null, $reply_to = null, $subject = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse';
        $request = $this->updateEmailContentUsingPOSTRequest($id, $from_email, $from_name, $reply_to, $subject);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateEmailContentUsingPOSTAsync
     *
     * Update Email Content
     *
     * @param  int $id id (required)
     * @param  \NecLimDul\MarketoRest\Asset\Model\EmailHeaderTypeValue $from_email (optional)
     * @param  \NecLimDul\MarketoRest\Asset\Model\EmailHeaderTypeValue $from_name (optional)
     * @param  \NecLimDul\MarketoRest\Asset\Model\EmailHeaderTypeValue $reply_to (optional)
     * @param  \NecLimDul\MarketoRest\Asset\Model\EmailHeaderTypeValue $subject (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEmailContentUsingPOSTAsync($id, $from_email = null, $from_name = null, $reply_to = null, $subject = null)
    {
        return $this->updateEmailContentUsingPOSTAsyncWithHttpInfo($id, $from_email, $from_name, $reply_to, $subject)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateEmailContentUsingPOSTAsyncWithHttpInfo
     *
     * Update Email Content
     *
     * @param  int $id id (required)
     * @param  \NecLimDul\MarketoRest\Asset\Model\EmailHeaderTypeValue $from_email (optional)
     * @param  \NecLimDul\MarketoRest\Asset\Model\EmailHeaderTypeValue $from_name (optional)
     * @param  \NecLimDul\MarketoRest\Asset\Model\EmailHeaderTypeValue $reply_to (optional)
     * @param  \NecLimDul\MarketoRest\Asset\Model\EmailHeaderTypeValue $subject (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEmailContentUsingPOSTAsyncWithHttpInfo($id, $from_email = null, $from_name = null, $reply_to = null, $subject = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse';
        $request = $this->updateEmailContentUsingPOSTRequest($id, $from_email, $from_name, $reply_to, $subject);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateEmailContentUsingPOST'
     *
     * @param  int $id id (required)
     * @param  \NecLimDul\MarketoRest\Asset\Model\EmailHeaderTypeValue $from_email (optional)
     * @param  \NecLimDul\MarketoRest\Asset\Model\EmailHeaderTypeValue $from_name (optional)
     * @param  \NecLimDul\MarketoRest\Asset\Model\EmailHeaderTypeValue $reply_to (optional)
     * @param  \NecLimDul\MarketoRest\Asset\Model\EmailHeaderTypeValue $subject (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateEmailContentUsingPOSTRequest($id, $from_email = null, $from_name = null, $reply_to = null, $subject = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateEmailContentUsingPOST'
            );
        }

        $resourcePath = '/rest/asset/v1/email/{id}/content.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // form params
        if ($from_email !== null) {
            $formParams['fromEmail'] = ObjectSerializer::toFormValue($from_email);
        }
        // form params
        if ($from_name !== null) {
            $formParams['fromName'] = ObjectSerializer::toFormValue($from_name);
        }
        // form params
        if ($reply_to !== null) {
            $formParams['replyTO'] = ObjectSerializer::toFormValue($reply_to);
        }
        // form params
        if ($subject !== null) {
            $formParams['subject'] = ObjectSerializer::toFormValue($subject);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateEmailDynamicContentUsingPOST
     *
     * Update Email Dynamic Content Section
     *
     * @param  int $id Id of email (required)
     * @param  string $content_id Id of email dynamic content section (required)
     * @param  string $type Type of content to set for the section. (required)
     * @param  string $value Value to set for the section.  For type Text, the HTML content of the section.  For type DynamicContent, the id of the segmentation to use for the content.  For type Snippet, the id of the snippet to embed (required)
     * @param  string $alt_text Sets the value of the alt parameter for the resulting img element (optional)
     * @param  string $external_url external_url (optional)
     * @param  int $height Overrides naitve height of the image.  The resulting file will be resized to the given height (optional)
     * @param  string $image Multipart file that allows you to add an image from your computer (optional)
     * @param  string $link_url link_url (optional)
     * @param  bool $over_write Allows overwriting of the existing image content section (optional)
     * @param  string $style Sets the value of the style parameter for the content section (optional)
     * @param  string $video_url Sets the Url of the video element.  Videos must be either from YouTube or Vimeo (optional)
     * @param  int $width Overrides native width of the image.  The resulting file will be resized to the given width (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse
     */
    public function updateEmailDynamicContentUsingPOST($id, $content_id, $type, $value, $alt_text = null, $external_url = null, $height = null, $image = null, $link_url = null, $over_write = null, $style = null, $video_url = null, $width = null)
    {
        list($response) = $this->updateEmailDynamicContentUsingPOSTWithHttpInfo($id, $content_id, $type, $value, $alt_text, $external_url, $height, $image, $link_url, $over_write, $style, $video_url, $width);
        return $response;
    }

    /**
     * Operation updateEmailDynamicContentUsingPOSTWithHttpInfo
     *
     * Update Email Dynamic Content Section
     *
     * @param  int $id Id of email (required)
     * @param  string $content_id Id of email dynamic content section (required)
     * @param  string $type Type of content to set for the section. (required)
     * @param  string $value Value to set for the section.  For type Text, the HTML content of the section.  For type DynamicContent, the id of the segmentation to use for the content.  For type Snippet, the id of the snippet to embed (required)
     * @param  string $alt_text Sets the value of the alt parameter for the resulting img element (optional)
     * @param  string $external_url (optional)
     * @param  int $height Overrides naitve height of the image.  The resulting file will be resized to the given height (optional)
     * @param  string $image Multipart file that allows you to add an image from your computer (optional)
     * @param  string $link_url (optional)
     * @param  bool $over_write Allows overwriting of the existing image content section (optional)
     * @param  string $style Sets the value of the style parameter for the content section (optional)
     * @param  string $video_url Sets the Url of the video element.  Videos must be either from YouTube or Vimeo (optional)
     * @param  int $width Overrides native width of the image.  The resulting file will be resized to the given width (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateEmailDynamicContentUsingPOSTWithHttpInfo($id, $content_id, $type, $value, $alt_text = null, $external_url = null, $height = null, $image = null, $link_url = null, $over_write = null, $style = null, $video_url = null, $width = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse';
        $request = $this->updateEmailDynamicContentUsingPOSTRequest($id, $content_id, $type, $value, $alt_text, $external_url, $height, $image, $link_url, $over_write, $style, $video_url, $width);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateEmailDynamicContentUsingPOSTAsync
     *
     * Update Email Dynamic Content Section
     *
     * @param  int $id Id of email (required)
     * @param  string $content_id Id of email dynamic content section (required)
     * @param  string $type Type of content to set for the section. (required)
     * @param  string $value Value to set for the section.  For type Text, the HTML content of the section.  For type DynamicContent, the id of the segmentation to use for the content.  For type Snippet, the id of the snippet to embed (required)
     * @param  string $alt_text Sets the value of the alt parameter for the resulting img element (optional)
     * @param  string $external_url (optional)
     * @param  int $height Overrides naitve height of the image.  The resulting file will be resized to the given height (optional)
     * @param  string $image Multipart file that allows you to add an image from your computer (optional)
     * @param  string $link_url (optional)
     * @param  bool $over_write Allows overwriting of the existing image content section (optional)
     * @param  string $style Sets the value of the style parameter for the content section (optional)
     * @param  string $video_url Sets the Url of the video element.  Videos must be either from YouTube or Vimeo (optional)
     * @param  int $width Overrides native width of the image.  The resulting file will be resized to the given width (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEmailDynamicContentUsingPOSTAsync($id, $content_id, $type, $value, $alt_text = null, $external_url = null, $height = null, $image = null, $link_url = null, $over_write = null, $style = null, $video_url = null, $width = null)
    {
        return $this->updateEmailDynamicContentUsingPOSTAsyncWithHttpInfo($id, $content_id, $type, $value, $alt_text, $external_url, $height, $image, $link_url, $over_write, $style, $video_url, $width)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateEmailDynamicContentUsingPOSTAsyncWithHttpInfo
     *
     * Update Email Dynamic Content Section
     *
     * @param  int $id Id of email (required)
     * @param  string $content_id Id of email dynamic content section (required)
     * @param  string $type Type of content to set for the section. (required)
     * @param  string $value Value to set for the section.  For type Text, the HTML content of the section.  For type DynamicContent, the id of the segmentation to use for the content.  For type Snippet, the id of the snippet to embed (required)
     * @param  string $alt_text Sets the value of the alt parameter for the resulting img element (optional)
     * @param  string $external_url (optional)
     * @param  int $height Overrides naitve height of the image.  The resulting file will be resized to the given height (optional)
     * @param  string $image Multipart file that allows you to add an image from your computer (optional)
     * @param  string $link_url (optional)
     * @param  bool $over_write Allows overwriting of the existing image content section (optional)
     * @param  string $style Sets the value of the style parameter for the content section (optional)
     * @param  string $video_url Sets the Url of the video element.  Videos must be either from YouTube or Vimeo (optional)
     * @param  int $width Overrides native width of the image.  The resulting file will be resized to the given width (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEmailDynamicContentUsingPOSTAsyncWithHttpInfo($id, $content_id, $type, $value, $alt_text = null, $external_url = null, $height = null, $image = null, $link_url = null, $over_write = null, $style = null, $video_url = null, $width = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfIdResponse';
        $request = $this->updateEmailDynamicContentUsingPOSTRequest($id, $content_id, $type, $value, $alt_text, $external_url, $height, $image, $link_url, $over_write, $style, $video_url, $width);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateEmailDynamicContentUsingPOST'
     *
     * @param  int $id Id of email (required)
     * @param  string $content_id Id of email dynamic content section (required)
     * @param  string $type Type of content to set for the section. (required)
     * @param  string $value Value to set for the section.  For type Text, the HTML content of the section.  For type DynamicContent, the id of the segmentation to use for the content.  For type Snippet, the id of the snippet to embed (required)
     * @param  string $alt_text Sets the value of the alt parameter for the resulting img element (optional)
     * @param  string $external_url (optional)
     * @param  int $height Overrides naitve height of the image.  The resulting file will be resized to the given height (optional)
     * @param  string $image Multipart file that allows you to add an image from your computer (optional)
     * @param  string $link_url (optional)
     * @param  bool $over_write Allows overwriting of the existing image content section (optional)
     * @param  string $style Sets the value of the style parameter for the content section (optional)
     * @param  string $video_url Sets the Url of the video element.  Videos must be either from YouTube or Vimeo (optional)
     * @param  int $width Overrides native width of the image.  The resulting file will be resized to the given width (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateEmailDynamicContentUsingPOSTRequest($id, $content_id, $type, $value, $alt_text = null, $external_url = null, $height = null, $image = null, $link_url = null, $over_write = null, $style = null, $video_url = null, $width = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateEmailDynamicContentUsingPOST'
            );
        }
        // verify the required parameter 'content_id' is set
        if ($content_id === null || (is_array($content_id) && count($content_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_id when calling updateEmailDynamicContentUsingPOST'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling updateEmailDynamicContentUsingPOST'
            );
        }
        // verify the required parameter 'value' is set
        if ($value === null || (is_array($value) && count($value) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $value when calling updateEmailDynamicContentUsingPOST'
            );
        }

        $resourcePath = '/rest/asset/v1/email/{id}/dynamicContent/{contentId}.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($content_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contentId' . '}',
                ObjectSerializer::toPathValue($content_id),
                $resourcePath
            );
        }

        // form params
        if ($alt_text !== null) {
            $formParams['altText'] = ObjectSerializer::toFormValue($alt_text);
        }
        // form params
        if ($external_url !== null) {
            $formParams['externalUrl'] = ObjectSerializer::toFormValue($external_url);
        }
        // form params
        if ($height !== null) {
            $formParams['height'] = ObjectSerializer::toFormValue($height);
        }
        // form params
        if ($image !== null) {
            $formParams['image'] = ObjectSerializer::toFormValue($image);
        }
        // form params
        if ($link_url !== null) {
            $formParams['linkUrl'] = ObjectSerializer::toFormValue($link_url);
        }
        // form params
        if ($over_write !== null) {
            $formParams['overWrite'] = ObjectSerializer::toFormValue($over_write);
        }
        // form params
        if ($style !== null) {
            $formParams['style'] = ObjectSerializer::toFormValue($style);
        }
        // form params
        if ($type !== null) {
            $formParams['type'] = ObjectSerializer::toFormValue($type);
        }
        // form params
        if ($value !== null) {
            $formParams['value'] = ObjectSerializer::toFormValue($value);
        }
        // form params
        if ($video_url !== null) {
            $formParams['videoUrl'] = ObjectSerializer::toFormValue($video_url);
        }
        // form params
        if ($width !== null) {
            $formParams['width'] = ObjectSerializer::toFormValue($width);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateEmailUsingPOST
     *
     * Update Email Metadata
     *
     * @param  int $id id (required)
     * @param  string $description Description of the asset (optional)
     * @param  string $name Name of the Email (optional)
     * @param  string $pre_header Preheader text for the email (optional)
     * @param  bool $operational Whether the email is operational.  Operational emails bypass unsubscribe status.  Defaults to false (optional)
     * @param  bool $published Whether the email has been published to Sales Insight.  Default false (optional)
     * @param  bool $text_only Setting to include text-only version of email when sent (optional)
     * @param  bool $web_view Whether the email has been enabled to allow the &#39;View as Web Page&#39; when received (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse
     */
    public function updateEmailUsingPOST($id, $description = null, $name = null, $pre_header = null, $operational = null, $published = null, $text_only = null, $web_view = null)
    {
        list($response) = $this->updateEmailUsingPOSTWithHttpInfo($id, $description, $name, $pre_header, $operational, $published, $text_only, $web_view);
        return $response;
    }

    /**
     * Operation updateEmailUsingPOSTWithHttpInfo
     *
     * Update Email Metadata
     *
     * @param  int $id id (required)
     * @param  string $description Description of the asset (optional)
     * @param  string $name Name of the Email (optional)
     * @param  string $pre_header Preheader text for the email (optional)
     * @param  bool $operational Whether the email is operational.  Operational emails bypass unsubscribe status.  Defaults to false (optional)
     * @param  bool $published Whether the email has been published to Sales Insight.  Default false (optional)
     * @param  bool $text_only Setting to include text-only version of email when sent (optional)
     * @param  bool $web_view Whether the email has been enabled to allow the &#39;View as Web Page&#39; when received (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateEmailUsingPOSTWithHttpInfo($id, $description = null, $name = null, $pre_header = null, $operational = null, $published = null, $text_only = null, $web_view = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse';
        $request = $this->updateEmailUsingPOSTRequest($id, $description, $name, $pre_header, $operational, $published, $text_only, $web_view);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateEmailUsingPOSTAsync
     *
     * Update Email Metadata
     *
     * @param  int $id id (required)
     * @param  string $description Description of the asset (optional)
     * @param  string $name Name of the Email (optional)
     * @param  string $pre_header Preheader text for the email (optional)
     * @param  bool $operational Whether the email is operational.  Operational emails bypass unsubscribe status.  Defaults to false (optional)
     * @param  bool $published Whether the email has been published to Sales Insight.  Default false (optional)
     * @param  bool $text_only Setting to include text-only version of email when sent (optional)
     * @param  bool $web_view Whether the email has been enabled to allow the &#39;View as Web Page&#39; when received (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEmailUsingPOSTAsync($id, $description = null, $name = null, $pre_header = null, $operational = null, $published = null, $text_only = null, $web_view = null)
    {
        return $this->updateEmailUsingPOSTAsyncWithHttpInfo($id, $description, $name, $pre_header, $operational, $published, $text_only, $web_view)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateEmailUsingPOSTAsyncWithHttpInfo
     *
     * Update Email Metadata
     *
     * @param  int $id id (required)
     * @param  string $description Description of the asset (optional)
     * @param  string $name Name of the Email (optional)
     * @param  string $pre_header Preheader text for the email (optional)
     * @param  bool $operational Whether the email is operational.  Operational emails bypass unsubscribe status.  Defaults to false (optional)
     * @param  bool $published Whether the email has been published to Sales Insight.  Default false (optional)
     * @param  bool $text_only Setting to include text-only version of email when sent (optional)
     * @param  bool $web_view Whether the email has been enabled to allow the &#39;View as Web Page&#39; when received (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEmailUsingPOSTAsyncWithHttpInfo($id, $description = null, $name = null, $pre_header = null, $operational = null, $published = null, $text_only = null, $web_view = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ResponseOfEmailResponse';
        $request = $this->updateEmailUsingPOSTRequest($id, $description, $name, $pre_header, $operational, $published, $text_only, $web_view);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateEmailUsingPOST'
     *
     * @param  int $id id (required)
     * @param  string $description Description of the asset (optional)
     * @param  string $name Name of the Email (optional)
     * @param  string $pre_header Preheader text for the email (optional)
     * @param  bool $operational Whether the email is operational.  Operational emails bypass unsubscribe status.  Defaults to false (optional)
     * @param  bool $published Whether the email has been published to Sales Insight.  Default false (optional)
     * @param  bool $text_only Setting to include text-only version of email when sent (optional)
     * @param  bool $web_view Whether the email has been enabled to allow the &#39;View as Web Page&#39; when received (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateEmailUsingPOSTRequest($id, $description = null, $name = null, $pre_header = null, $operational = null, $published = null, $text_only = null, $web_view = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateEmailUsingPOST'
            );
        }

        $resourcePath = '/rest/asset/v1/email/{id}.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // form params
        if ($description !== null) {
            $formParams['description'] = ObjectSerializer::toFormValue($description);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($pre_header !== null) {
            $formParams['preHeader'] = ObjectSerializer::toFormValue($pre_header);
        }
        // form params
        if ($operational !== null) {
            $formParams['operational'] = ObjectSerializer::toFormValue($operational);
        }
        // form params
        if ($published !== null) {
            $formParams['published'] = ObjectSerializer::toFormValue($published);
        }
        // form params
        if ($text_only !== null) {
            $formParams['textOnly'] = ObjectSerializer::toFormValue($text_only);
        }
        // form params
        if ($web_view !== null) {
            $formParams['webView'] = ObjectSerializer::toFormValue($web_view);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateVariableUsingPOST
     *
     * Update Email Variable
     *
     * @param  int $id id (required)
     * @param  string $name name (required)
     * @param  string $value Value to update variable with (optional)
     * @param  string $module_id Module that variable is associated with. Required for updating module variables. Not needed for global variables. (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \NecLimDul\MarketoRest\Asset\Model\ModelResponse
     */
    public function updateVariableUsingPOST($id, $name, $value = null, $module_id = null)
    {
        list($response) = $this->updateVariableUsingPOSTWithHttpInfo($id, $name, $value, $module_id);
        return $response;
    }

    /**
     * Operation updateVariableUsingPOSTWithHttpInfo
     *
     * Update Email Variable
     *
     * @param  int $id id (required)
     * @param  string $name name (required)
     * @param  string $value Value to update variable with (optional)
     * @param  string $module_id Module that variable is associated with. Required for updating module variables. Not needed for global variables. (optional)
     *
     * @throws \NecLimDul\MarketoRest\Asset\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \NecLimDul\MarketoRest\Asset\Model\ModelResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateVariableUsingPOSTWithHttpInfo($id, $name, $value = null, $module_id = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ModelResponse';
        $request = $this->updateVariableUsingPOSTRequest($id, $name, $value, $module_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\NecLimDul\MarketoRest\Asset\Model\ModelResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateVariableUsingPOSTAsync
     *
     * Update Email Variable
     *
     * @param  int $id id (required)
     * @param  string $name name (required)
     * @param  string $value Value to update variable with (optional)
     * @param  string $module_id Module that variable is associated with. Required for updating module variables. Not needed for global variables. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateVariableUsingPOSTAsync($id, $name, $value = null, $module_id = null)
    {
        return $this->updateVariableUsingPOSTAsyncWithHttpInfo($id, $name, $value, $module_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateVariableUsingPOSTAsyncWithHttpInfo
     *
     * Update Email Variable
     *
     * @param  int $id id (required)
     * @param  string $name name (required)
     * @param  string $value Value to update variable with (optional)
     * @param  string $module_id Module that variable is associated with. Required for updating module variables. Not needed for global variables. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateVariableUsingPOSTAsyncWithHttpInfo($id, $name, $value = null, $module_id = null)
    {
        $returnType = '\NecLimDul\MarketoRest\Asset\Model\ModelResponse';
        $request = $this->updateVariableUsingPOSTRequest($id, $name, $value, $module_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateVariableUsingPOST'
     *
     * @param  int $id id (required)
     * @param  string $name name (required)
     * @param  string $value Value to update variable with (optional)
     * @param  string $module_id Module that variable is associated with. Required for updating module variables. Not needed for global variables. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateVariableUsingPOSTRequest($id, $name, $value = null, $module_id = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateVariableUsingPOST'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling updateVariableUsingPOST'
            );
        }

        $resourcePath = '/rest/asset/v1/email/{id}/variable/{name}.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // form params
        if ($value !== null) {
            $formParams['value'] = ObjectSerializer::toFormValue($value);
        }
        // form params
        if ($module_id !== null) {
            $formParams['moduleId'] = ObjectSerializer::toFormValue($module_id);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
